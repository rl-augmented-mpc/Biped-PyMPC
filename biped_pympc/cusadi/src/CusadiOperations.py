
# CUDA definitions for all CasADi atomic operations
#   Nearly all symbolic, scalar operations are included here.
#   Exhaustive list: https://github.com/casadi/casadi/blob/main/casadi/core/calculus.hpp

# CUDA libraries may need to be manually added for compilation:
#   export PATH="/usr/local/cuda-12.3/bin:$PATH"
#   export LD_LIBRARY_PATH="/usr/local/cuda-12.3/lib64:$LD_LIBRARY_PATH"

from casadi import *

OP_CUDA_DICT_ORIG = {
    OP_ASSIGN:              "\n        work[idx * n_w + %d] = work[idx * n_w + %d];",
    OP_ADD:                 "\n        work[idx * n_w + %d] = work[idx * n_w + %d] + work[idx * n_w + %d];",
    OP_SUB:                 "\n        work[idx * n_w + %d] = work[idx * n_w + %d] - work[idx * n_w + %d];",
    OP_MUL:                 "\n        work[idx * n_w + %d] = work[idx * n_w + %d] * work[idx * n_w + %d];",
    OP_DIV:                 "\n        work[idx * n_w + %d] = work[idx * n_w + %d] / work[idx * n_w + %d];",
    OP_NEG:                 "\n        work[idx * n_w + %d] = -work[idx * n_w + %d];",
    OP_EXP:                 "\n        work[idx * n_w + %d] = exp(work[idx * n_w + %d]);",
    OP_LOG:                 "\n        work[idx * n_w + %d] = log(work[idx * n_w + %d]);",
    OP_POW:                 "\n        work[idx * n_w + %d] = pow(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_CONSTPOW:            "\n        work[idx * n_w + %d] = pow(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_SQRT:                "\n        work[idx * n_w + %d] = sqrt(work[idx * n_w + %d]);",
    OP_SQ:                  "\n        work[idx * n_w + %d] = work[idx * n_w + %d] * work[idx * n_w + %d];",
    OP_TWICE:               "\n        work[idx * n_w + %d] = 2.*(work[idx * n_w + %d]);",
    OP_SIN:                 "\n        work[idx * n_w + %d] = sin(work[idx * n_w + %d]);",
    OP_COS:                 "\n        work[idx * n_w + %d] = cos(work[idx * n_w + %d]);",
    OP_TAN:                 "\n        work[idx * n_w + %d] = tan(work[idx * n_w + %d]);",
    OP_ASIN:                "\n        work[idx * n_w + %d] = asin(work[idx * n_w + %d]);",
    OP_ACOS:                "\n        work[idx * n_w + %d] = acos(work[idx * n_w + %d]);",
    OP_ATAN:                "\n        work[idx * n_w + %d] = atan(work[idx * n_w + %d]);",
    OP_LT:                  "\n        work[idx * n_w + %d] = work[idx * n_w + %d] < work[idx * n_w + %d];",
    OP_LE:                  "\n        work[idx * n_w + %d] = work[idx * n_w + %d] <= work[idx * n_w + %d];",
    OP_EQ:                  "\n        work[idx * n_w + %d] = work[idx * n_w + %d] == work[idx * n_w + %d];",
    OP_NE:                  "\n        work[idx * n_w + %d] = work[idx * n_w + %d] != work[idx * n_w + %d];",
    OP_NOT:                 "\n        work[idx * n_w + %d] = !work[idx * n_w + %d];",
    OP_AND:                 "\n        work[idx * n_w + %d] = work[idx * n_w + %d] && work[idx * n_w + %d];",
    OP_OR:                  "\n        work[idx * n_w + %d] = work[idx * n_w + %d] || work[idx * n_w + %d];",
    OP_FLOOR:               "\n        work[idx * n_w + %d] = floor(work[idx * n_w + %d]);",
    OP_CEIL:                "\n        work[idx * n_w + %d] = ceil(work[idx * n_w + %d]);",
    OP_FMOD:                "\n        work[idx * n_w + %d] = fmod(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_FABS:                "\n        work[idx * n_w + %d] = fabs(work[idx * n_w + %d]);",
    OP_SIGN:                "\n        work[idx * n_w + %d] = sign(work[idx * n_w + %d]);",
    OP_COPYSIGN:            "\n        work[idx * n_w + %d] = copysign(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_IF_ELSE_ZERO:        "\n        work[idx * n_w + %d] = (work[idx * n_w + %d] == 0) ? 0 : work[idx * n_w + %d];",
    OP_ERF:                 "\n        work[idx * n_w + %d] = erf(work[idx * n_w + %d]);",
    OP_FMIN:                "\n        work[idx * n_w + %d] = fmin(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_FMAX:                "\n        work[idx * n_w + %d] = fmax(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_INV:                 "\n        work[idx * n_w + %d] = 1./(work[idx * n_w + %d]);",
    OP_SINH:                "\n        work[idx * n_w + %d] = sinh(work[idx * n_w + %d]);",
    OP_COSH:                "\n        work[idx * n_w + %d] = cosh(work[idx * n_w + %d]);",
    OP_TANH:                "\n        work[idx * n_w + %d] = tanh(work[idx * n_w + %d]);",
    OP_ASINH:               "\n        work[idx * n_w + %d] = asinh(work[idx * n_w + %d]);",
    OP_ACOSH:               "\n        work[idx * n_w + %d] = acosh(work[idx * n_w + %d]);",
    OP_ATANH:               "\n        work[idx * n_w + %d] = atanh(work[idx * n_w + %d]);",
    OP_ATAN2:               "\n        work[idx * n_w + %d] = atan2(work[idx * n_w + %d], work[idx * n_w + %d]);",
    OP_CONST:               "\n        work[idx * n_w + %d] = %.16f;",
    OP_INPUT:               "\n        work[idx * n_w + %d] = inputs[%d][idx * nnz_in[%d] + %d];",
    OP_OUTPUT:              "\n        outputs[%d][idx * nnz_out[%d] + %d] = work[idx * n_w + %d];",
}


OP_CUDA_DICT = {
    OP_ASSIGN:              "\n        work[env_idx + %d] = work[env_idx + %d];",
    OP_ADD:                 "\n        work[env_idx + %d] = work[env_idx + %d] + work[env_idx + %d];",
    OP_SUB:                 "\n        work[env_idx + %d] = work[env_idx + %d] - work[env_idx + %d];",
    OP_MUL:                 "\n        work[env_idx + %d] = work[env_idx + %d] * work[env_idx + %d];",
    OP_DIV:                 "\n        work[env_idx + %d] = work[env_idx + %d] / work[env_idx + %d];",
    OP_NEG:                 "\n        work[env_idx + %d] = -work[env_idx + %d];",
    OP_EXP:                 "\n        work[env_idx + %d] = exp(work[env_idx + %d]);",
    OP_LOG:                 "\n        work[env_idx + %d] = log(work[env_idx + %d]);",
    OP_POW:                 "\n        work[env_idx + %d] = pow(work[env_idx + %d], work[env_idx + %d]);",
    OP_CONSTPOW:            "\n        work[env_idx + %d] = pow(work[env_idx + %d], work[env_idx + %d]);",
    OP_SQRT:                "\n        work[env_idx + %d] = sqrt(work[env_idx + %d]);",
    OP_SQ:                  "\n        work[env_idx + %d] = work[env_idx + %d] * work[env_idx + %d];",
    OP_TWICE:               "\n        work[env_idx + %d] = 2.*(work[env_idx + %d]);",
    OP_SIN:                 "\n        work[env_idx + %d] = sin(work[env_idx + %d]);",
    OP_COS:                 "\n        work[env_idx + %d] = cos(work[env_idx + %d]);",
    OP_TAN:                 "\n        work[env_idx + %d] = tan(work[env_idx + %d]);",
    OP_ASIN:                "\n        work[env_idx + %d] = asin(work[env_idx + %d]);",
    OP_ACOS:                "\n        work[env_idx + %d] = acos(work[env_idx + %d]);",
    OP_ATAN:                "\n        work[env_idx + %d] = atan(work[env_idx + %d]);",
    OP_LT:                  "\n        work[env_idx + %d] = work[env_idx + %d] < work[env_idx + %d];",
    OP_LE:                  "\n        work[env_idx + %d] = work[env_idx + %d] <= work[env_idx + %d];",
    OP_EQ:                  "\n        work[env_idx + %d] = work[env_idx + %d] == work[env_idx + %d];",
    OP_NE:                  "\n        work[env_idx + %d] = work[env_idx + %d] != work[env_idx + %d];",
    OP_NOT:                 "\n        work[env_idx + %d] = !work[env_idx + %d];",
    OP_AND:                 "\n        work[env_idx + %d] = work[env_idx + %d] && work[env_idx + %d];",
    OP_OR:                  "\n        work[env_idx + %d] = work[env_idx + %d] || work[env_idx + %d];",
    OP_FLOOR:               "\n        work[env_idx + %d] = floor(work[env_idx + %d]);",
    OP_CEIL:                "\n        work[env_idx + %d] = ceil(work[env_idx + %d]);",
    OP_FMOD:                "\n        work[env_idx + %d] = fmod(work[env_idx + %d], work[env_idx + %d]);",
    OP_FABS:                "\n        work[env_idx + %d] = fabs(work[env_idx + %d]);",
    OP_SIGN:                "\n        work[env_idx + %d] = sign(work[env_idx + %d]);",
    OP_COPYSIGN:            "\n        work[env_idx + %d] = copysign(work[env_idx + %d], work[env_idx + %d]);",
    OP_IF_ELSE_ZERO:        "\n        work[env_idx + %d] = (work[env_idx + %d] == 0) ? 0 : work[env_idx + %d];",
    OP_ERF:                 "\n        work[env_idx + %d] = erf(work[env_idx + %d]);",
    OP_FMIN:                "\n        work[env_idx + %d] = fmin(work[env_idx + %d], work[env_idx + %d]);",
    OP_FMAX:                "\n        work[env_idx + %d] = fmax(work[env_idx + %d], work[env_idx + %d]);",
    OP_INV:                 "\n        work[env_idx + %d] = 1./(work[env_idx + %d]);",
    OP_SINH:                "\n        work[env_idx + %d] = sinh(work[env_idx + %d]);",
    OP_COSH:                "\n        work[env_idx + %d] = cosh(work[env_idx + %d]);",
    OP_TANH:                "\n        work[env_idx + %d] = tanh(work[env_idx + %d]);",
    OP_ASINH:               "\n        work[env_idx + %d] = asinh(work[env_idx + %d]);",
    OP_ACOSH:               "\n        work[env_idx + %d] = acosh(work[env_idx + %d]);",
    OP_ATANH:               "\n        work[env_idx + %d] = atanh(work[env_idx + %d]);",
    OP_ATAN2:               "\n        work[env_idx + %d] = atan2(work[env_idx + %d], work[env_idx + %d]);",
    OP_CONST:               "\n        work[env_idx + %d] = %.16f;",
    OP_INPUT:               "\n        work[env_idx + %d] = inputs[%d][idx * nnz_in[%d] + %d];",
    OP_OUTPUT:              "\n        outputs[%d][idx * nnz_out[%d] + %d] = work[env_idx + %d];",
}


OP_PYTORCH_DICT = {
    OP_ASSIGN:              "\n        work[%d] = work[%d]",
    OP_ADD:                 "\n        work[%d] = work[%d] + work[%d]",
    OP_SUB:                 "\n        work[%d] = work[%d] - work[%d]",
    OP_MUL:                 "\n        work[%d] = work[%d] * work[%d]",
    OP_DIV:                 "\n        work[%d] = work[%d] / work[%d]",
    OP_NEG:                 "\n        work[%d] = -work[%d]",
    OP_EXP:                 "\n        work[%d] = torch.exp(work[%d])",
    OP_LOG:                 "\n        work[%d] = torch.log(work[%d])",
    OP_POW:                 "\n        work[%d] = torch.pow(work[%d], work[%d])",
    OP_CONSTPOW:            "\n        work[%d] = torch.pow(work[%d], work[%d])",
    OP_SQRT:                "\n        work[%d] = torch.sqrt(work[%d])",
    OP_SQ:                  "\n        work[%d] = work[%d] * work[%d]",
    OP_TWICE:               "\n        work[%d] = 2.*(work[%d])",
    OP_SIN:                 "\n        work[%d] = torch.sin(work[%d])",
    OP_COS:                 "\n        work[%d] = torch.cos(work[%d])",
    OP_TAN:                 "\n        work[%d] = torch.tan(work[%d])",
    OP_ASIN:                "\n        work[%d] = torch.asin(work[%d])",
    OP_ACOS:                "\n        work[%d] = torch.acos(work[%d])",
    OP_ATAN:                "\n        work[%d] = torch.atan(work[%d])",
    OP_LT:                  "\n        work[%d] = work[%d] < work[%d]",
    OP_LE:                  "\n        work[%d] = work[%d] <= work[%d]",
    OP_EQ:                  "\n        work[%d] = work[%d] == work[%d]",
    OP_NE:                  "\n        work[%d] = work[%d] != work[%d]",
    OP_NOT:                 "\n        work[%d] = torch.logical_not(work[%d])",
    OP_AND:                 "\n        work[%d] = torch.logical_and(work[%d], work[%d])",
    OP_OR:                  "\n        work[%d] = torch.logical_or(work[%d], work[%d])",
    OP_FLOOR:               "\n        work[%d] = torch.floor(work[%d])",
    OP_CEIL:                "\n        work[%d] = torch.ceil(work[%d])",
    OP_FMOD:                "\n        work[%d] = torch.fmod(work[%d], work[%d])",
    OP_FABS:                "\n        work[%d] = torch.abs(work[%d])",
    OP_SIGN:                "\n        work[%d] = torch.sign(work[%d])",
    OP_COPYSIGN:            "\n        work[%d] = torch.copysign(work[%d], work[%d])",
    OP_IF_ELSE_ZERO:        "\n        work[%d] = (work[%d] == 0) ? 0 : work[%d]",
    OP_ERF:                 "\n        work[%d] = torch.erf(work[%d])",
    OP_FMIN:                "\n        work[%d] = torch.fmin(work[%d], work[%d])",
    OP_FMAX:                "\n        work[%d] = torch.fmax(work[%d], work[%d])",
    OP_INV:                 "\n        work[%d] = 1./(work[%d])",
    OP_SINH:                "\n        work[%d] = torch.sinh(work[%d])",
    OP_COSH:                "\n        work[%d] = torch.cosh(work[%d])",
    OP_TANH:                "\n        work[%d] = torch.tanh(work[%d])",
    OP_ASINH:               "\n        work[%d] = torch.asinh(work[%d])",
    OP_ACOSH:               "\n        work[%d] = torch.acosh(work[%d])",
    OP_ATANH:               "\n        work[%d] = torch.atanh(work[%d])",
    OP_ATAN2:               "\n        work[%d] = torch.atan2(work[%d], work[%d])",
    OP_CONST:               "\n        work[%d] = %f",
    OP_INPUT:               "\n        work[%d] = inputs[%d][%d]",
    OP_OUTPUT:              "\n        outputs[%d][%d] = work[%d]",
}

# OP_PYTORCH_DICT = {
#     OP_ASSIGN:              "\n        work[:, %d] = work[:, %d]",
#     OP_ADD:                 "\n        work[:, %d] = work[:, %d] + work[:, %d]",
#     OP_SUB:                 "\n        work[:, %d] = work[:, %d] - work[:, %d]",
#     OP_MUL:                 "\n        work[:, %d] = work[:, %d] * work[:, %d]",
#     OP_DIV:                 "\n        work[:, %d] = work[:, %d] / work[:, %d]",
#     OP_NEG:                 "\n        work[:, %d] = -work[:, %d]",
#     OP_EXP:                 "\n        work[:, %d] = torch.exp(work[:, %d])",
#     OP_LOG:                 "\n        work[:, %d] = torch.log(work[:, %d])",
#     OP_POW:                 "\n        work[:, %d] = torch.pow(work[:, %d], work[:, %d])",
#     OP_CONSTPOW:            "\n        work[:, %d] = torch.pow(work[:, %d], work[:, %d])",
#     OP_SQRT:                "\n        work[:, %d] = torch.sqrt(work[:, %d])",
#     OP_SQ:                  "\n        work[:, %d] = work[:, %d] * work[:, %d]",
#     OP_TWICE:               "\n        work[:, %d] = 2.*(work[:, %d])",
#     OP_SIN:                 "\n        work[:, %d] = torch.sin(work[:, %d])",
#     OP_COS:                 "\n        work[:, %d] = torch.cos(work[:, %d])",
#     OP_TAN:                 "\n        work[:, %d] = torch.tan(work[:, %d])",
#     OP_ASIN:                "\n        work[:, %d] = torch.asin(work[:, %d])",
#     OP_ACOS:                "\n        work[:, %d] = torch.acos(work[:, %d])",
#     OP_ATAN:                "\n        work[:, %d] = torch.atan(work[:, %d])",
#     OP_LT:                  "\n        work[:, %d] = work[:, %d] < work[:, %d]",
#     OP_LE:                  "\n        work[:, %d] = work[:, %d] <= work[:, %d]",
#     OP_EQ:                  "\n        work[:, %d] = work[:, %d] == work[:, %d]",
#     OP_NE:                  "\n        work[:, %d] = work[:, %d] != work[:, %d]",
#     OP_NOT:                 "\n        work[:, %d] = torch.logical_not(work[:, %d])",
#     OP_AND:                 "\n        work[:, %d] = torch.logical_and(work[:, %d], work[:, %d])",
#     OP_OR:                  "\n        work[:, %d] = torch.logical_or(work[:, %d], work[:, %d])",
#     OP_FLOOR:               "\n        work[:, %d] = torch.floor(work[:, %d])",
#     OP_CEIL:                "\n        work[:, %d] = torch.ceil(work[:, %d])",
#     OP_FMOD:                "\n        work[:, %d] = torch.fmod(work[:, %d], work[:, %d])",
#     OP_FABS:                "\n        work[:, %d] = torch.abs(work[:, %d])",
#     OP_SIGN:                "\n        work[:, %d] = torch.sign(work[:, %d])",
#     OP_COPYSIGN:            "\n        work[:, %d] = torch.copysign(work[:, %d], work[:, %d])",
#     OP_IF_ELSE_ZERO:        "\n        work[:, %d] = (work[:, %d] == 0) ? 0 : work[:, %d]",
#     OP_ERF:                 "\n        work[:, %d] = torch.erf(work[:, %d])",
#     OP_FMIN:                "\n        work[:, %d] = torch.fmin(work[:, %d], work[:, %d])",
#     OP_FMAX:                "\n        work[:, %d] = torch.fmax(work[:, %d], work[:, %d])",
#     OP_INV:                 "\n        work[:, %d] = 1./(work[:, %d])",
#     OP_SINH:                "\n        work[:, %d] = torch.sinh(work[:, %d])",
#     OP_COSH:                "\n        work[:, %d] = torch.cosh(work[:, %d])",
#     OP_TANH:                "\n        work[:, %d] = torch.tanh(work[:, %d])",
#     OP_ASINH:               "\n        work[:, %d] = torch.asinh(work[:, %d])",
#     OP_ACOSH:               "\n        work[:, %d] = torch.acosh(work[:, %d])",
#     OP_ATANH:               "\n        work[:, %d] = torch.atanh(work[:, %d])",
#     OP_ATAN2:               "\n        work[:, %d] = torch.atan2(work[:, %d], work[:, %d])",
#     OP_CONST:               "\n        work[:, %d] = %f",
#     OP_INPUT:               "\n        work[:, %d] = inputs[%d][:, %d]",
#     OP_OUTPUT:              "\n        outputs[%d][:, %d] = work[:, %d]",
# }
